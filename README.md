# Oil price service &emsp; [![Build Status]][actions]
[Build Status]: https://img.shields.io/github/workflow/status/EnoughTea/embedika-oil-price-service/CI/main
[actions]: https://github.com/EnoughTea/embedika-oil-price-service/actions?query=branch%3Amain

It's a toy project, test item #1 for [Embedika](https://embedika.ru/) company, simple microservice used to provide downloaded and parsed oil prices, nothing to see here.
___


## Описание

Это микросервис на akka-http, предоставляющий несколько эндпойнтов для получения информации о ценах на нефть.

Для своей внутренней логики сервис кэширует и пытается раз в час обновлять записи с ценами с Data.gov.ru,
но он больше времени лежит, чем стоит, поэтому есть фоллбэк на локальный файл с ценами в JAR’е. HTTP-запросы кэшируются отдельно через `akka-http-caching`.

Записи с ценами в памяти поддерживаются отсортированными по возврастанию даты
для возможности бинарного поиска ближайшей к целевой дате записи.

Чтобы не потерять точность и избежать ошибок округления при работе с ценами, используется
[Squants](https://github.com/typelevel/squants).

Статистики нет, хотя планировалась, но увы. Фронта нет и не планировалось.


### Архитектура одним списком

* `OilPriceSource` предоставляет локальное и удалённое места, откуда можно получить сырые данные с ценами;
* `OilPriceProvider` абстрагирует то, как сырые данные получаются и превращаются в распарсенные цены, 
а `OilPriceCsvParser` ему помогает в парсинге CSV.
* `OilPriceCache` скрывает процесс получения свежих цен от провайдеров и обновления их в памяти,
позволяя просто делать get() и не думать о том, пойдём мы в интернет или не пойдём.
* `OilPriceService` реализует бизнес-логику эндпойнтов: расчёты средней-минимальной-максимальной цен нахоядтся в нём.
* `OilPriceServiceRoutes` содержит сами эндпойнты с валидацией параметров. 
* Его помощник `Routes` оборачивает эндпойнты в общую для всех обвязку.
* Контексты выполнения явно разделяются на `CpuExecutionContext` и `IoExecutionContext`, 
чтобы не запутаться в implicit’ах и не перепутать, на чём качать цены, а на чём находить минимум-максимум.
* Архитектура заточена под нескольких провайдеров, но реально существует только один: data.gov.ru


## Эндпойнты

Формат даты во всех эндпойнтах — стандартный ISO-8601: `2013-04-14`

### Все записи средних цен на нефть от провайдера

```
curl --request GET \
  --url http://127.0.0.1:8045/prices/data.gov.ru/all
```

Пример возвращаемого JSON-списка:
```
[
	{
		"dates": "2013-03-15, 2013-04-14",
		"price": "764.6 RUB"
	},
	{
		"dates": "2013-04-15, 2013-05-14",
		"price": "732.8 RUB"
	},
	{
		"dates": "2013-05-15, 2013-06-14",
		"price": "749.3 RUB"
	}
]
```


### Средняя цена на нефть в заданный день

```
curl --request GET \
  --url 'http://127.0.0.1:8045/prices/data.gov.ru/single?date=2020-12-31'
```

Пример возвращаемой JSON-строки: `"377.4 RUB"`

Возвращает 404, если у провайдера нет записей о цене на заданную дату.


### Средняя цена на нефть в заданном временном промежутке

```
curl --request GET \
  --url 'http://127.0.0.1:8045/prices/data.gov.ru/averageover?startDate=2019-12-31&endDate=2021-01-01'
```

Пример возвращаемой JSON-строки: `"303.7 RUB"`

Возвращает 404, если заданный диапазон дат не пересекается ни с одной записью о цене.

### Минимальная и максимальная цены на нефть в заданном временном промежутке

```
curl --request GET \
  --url 'http://127.0.0.1:8045/prices/data.gov.ru/minmax?startDate=2019-01-01&endDate=2021-01-01'
```

Пример возвращаемого JSON-объекта:
```
{
	"min": "138.7 RUB",
	"max": "527.3 RUB"
}
```
Возвращает 404, если заданный диапазон дат не пересекается ни с одной записью о цене.


### Информация о всех провайдерах цен
```
curl --request GET \
  --url http://127.0.0.1:8045/prices/stats
```

Пример возвращаемого JSON-массива:
```
[
	{
		"providerId": "Data.gov.ru",
		"totalOilPriceRecords": 111
	}
]
```

## Пуск и выпуск

`sbt run`, или если хочется вызвать отдельный исполняемый файл, 
можно сделать `sbt pack` и вызвать `.\target\pack\bin\main`. 
Если же нужен архив с программой: `sbt Universal / packageBin`.


### Docker

Образ делается через [sbt-native-packager](https://www.scala-sbt.org/sbt-native-packager/formats/docker.html),
настраиваемый в `build.sbt`. 
Создать локальный образ и запустить его можно так (сервис слушает 8045 порт и выключается по ньюлайну в stdin):

```
sbt Docker / publishLocal
docker run -i -p 8045:8045 oil-price-service:1.0.0
```
